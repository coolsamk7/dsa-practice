# Basic Recursion Problems
1. **Factorial of a Number**: Compute the factorial of a number `n` using recursion.
2. **Fibonacci Sequence**: Find the nth Fibonacci number using recursion.
3. **Sum of Digits**: Find the sum of digits of a number using recursion.
4. **Power of a Number**: Calculate `x^n` (power of a number) using recursion.
5. **Greatest Common Divisor (GCD)**: Find the GCD of two numbers using the Euclidean algorithm and recursion.
6. **Print Numbers from 1 to n**: Write a recursive function to print numbers from 1 to `n`.
7. **Print Numbers from n to 1**: Write a recursive function to print numbers from `n` to 1.
8. **Reverse a String**: Reverse a string using recursion.
9. **Check Palindrome**: Check if a given string is a palindrome using recursion.
10. **Find Length of a String**: Find the length of a string using recursion.

# Intermediate Recursion Problems
1. **Towers of Hanoi**: Solve the Towers of Hanoi problem for `n` disks.
2. **Sum of Array Elements**: Find the sum of all elements in an array using recursion.
3. **Binary Search**: Implement binary search using recursion.
4. **Find Maximum Element in Array**: Find the maximum element in an array using recursion.
5. **Check Sorted Array**: Check if an array is sorted using recursion.
6. **Subset Sum**: Check if a subset exists with a given sum using recursion.
7. **Count Subsets with Given Sum**: Count all subsets with a given sum using recursion.
8. **Generate All Subsets**: Generate all subsets (power set) of a set using recursion.
9. **String Permutations**: Generate all permutations of a given string using recursion.
10. **Array Permutations**: Generate all permutations of an array using recursion.

# Advanced Recursion Problems
1. **N-Queens Problem**: Solve the N-Queens problem using recursion and backtracking.
2. **Rat in a Maze**: Find all possible paths for a rat in a maze using recursion and backtracking.
3. **Word Search**: Search for a word in a 2D grid using recursion and backtracking.
4. **Sudoku Solver**: Implement a Sudoku solver using recursion and backtracking.
5. **Palindrome Partitioning**: Partition a string into palindromic substrings using recursion.
6. **All Unique Subsets**: Generate all unique subsets of a set (handles duplicates) using recursion.
7. **Combination Sum**: Find all combinations that sum to a target using recursion.
8. **Letter Combinations of a Phone Number**: Generate all possible letter combinations of a phone number using recursion.
9. **Find All Anagrams**: Generate all anagrams of a string using recursion.
10. **Generate Balanced Parentheses**: Generate all combinations of well-formed parentheses for `n` pairs using recursion.

# Dynamic Programming with Recursion (Memoization)
1. **Climbing Stairs**: Find the number of ways to climb `n` stairs using recursion and memoization.
2. **Coin Change Problem**: Find the minimum number of coins required to make a change for a given amount using recursion.
3. **Longest Common Subsequence (LCS)**: Find the longest common subsequence between two strings using recursion.
4. **Longest Palindromic Subsequence**: Find the longest palindromic subsequence of a string using recursion.
5. **Knapsack Problem**: Solve the 0/1 Knapsack problem using recursion and memoization.
6. **Edit Distance**: Find the minimum number of edits (insertions, deletions, replacements) to convert one string into another.
7. **Word Break Problem**: Check if a string can be segmented into words from a dictionary using recursion and memoization.
8. **Rod Cutting Problem**: Maximize the value obtained by cutting a rod into pieces using recursion.
9. **House Robber Problem**: Maximize the amount of money a robber can rob without robbing two adjacent houses using recursion.
10. **Matrix Chain Multiplication**: Find the most efficient way to multiply a chain of matrices using recursion.

# Combinatorial Recursion Problems
1. **Generate Permutations with Duplicates Allowed**: Generate all permutations of a string with duplicate characters.
2. **Combinations of k Numbers**: Generate all combinations of `k` numbers from 1 to `n`.
3. **Josephus Problem**: Solve the Josephus problem using recursion.
4. **Gray Code**: Generate the Gray code sequence using recursion.
5. **Lexicographical Order**: Generate numbers from 1 to `n` in lexicographical order using recursion.
6. **Print All Paths in a Matrix**: Print all possible paths from the top-left to the bottom-right corner of a matrix using recursion.
7. **Generate All Palindromic Permutations**: Generate all palindromic permutations of a string using recursion.
8. **Combinations of n Choose k**: Generate all combinations of `n` elements taken `k` at a time using recursion.
9. **Number of Islands**: Find the number of islands in a grid (connected components problem) using recursion.
10. **Unique Paths**: Find the number of unique paths from the top-left to the bottom-right corner of a matrix using recursion.

# How to Approach Recursion Problems:
- **Base Case**: Identify the smallest subproblem that has a straightforward solution.
- **Recursive Step**: Break the problem into smaller subproblems and call the function recursively.
- **Memoization**: For problems with overlapping subproblems (like DP), store solutions to avoid recalculating.
- **Backtracking**: For combinatorial problems, explore all possible solutions and prune the ones that donâ€™t meet the criteria.

These problems cover a wide spectrum of recursion-related topics and are suitable for practice in competitive programming, technical interviews, or for improving your understanding of recursion in general.
